exam_notes3 <- function() {
  cat(
    "### Exam Notes 3: Quick R Reference\n\n",
    "### 1. Implicit Loops\n",
    "  - **`apply(x, margin, func, args)`**: Apply a function across rows or columns of a matrix/data frame.\n",
    "    - **`margin = 1`**: Apply across rows.\n",
    "    - **`margin = 2`**: Apply across columns.\n",
    "    - Example: Compute row means while handling missing values:\n",
    "      ```R\n",
    "      mat <- matrix(c(1, NA, 3, 4), nrow = 2)\n",
    "      apply(mat, 1, mean, na.rm = TRUE)\n",
    "      ```\n\n",
    "  - **`sapply(x, func)`**: Simplifies results when applying a function to vector/list elements.\n",
    "    - Example: `sapply(1:5, function(x) x^2)` -> Squares numbers 1 to 5.\n\n",
    "  - **`lapply(x, func)`**: Similar to `sapply`, but always returns a list.\n",
    "    - Example: `lapply(1:5, function(x) x^2)` -> Returns a list of squares.\n\n",
    "---\n\n",
    "### 2. Custom Functions\n",
    "  - Functions encapsulate reusable code. Define functions using `function()`.\n",
    "    - Example:\n",
    "      ```R\n",
    "      add <- function(a, b) {\n",
    "        return(a + b)\n",
    "      }\n",
    "      add(3, 5)  # Returns 8\n",
    "      ```\n\n",
    "---\n\n",
    "### 3. Reusability\n",
    "  - Save functions in an `.R` script (e.g., `my_functions.R`) and load them using:\n",
    "    ```R\n",
    "    source('my_functions.R')\n",
    "    ```\n",
    "  - This makes functions reusable and allows for cleaner, modular scripts.\n\n",
    "---\n\n",
    "### 4. Error Handling\n",
    "  - **Validation with `stop()` and `warning()`**:\n",
    "    - **`stop()`**: Ends the function and throws an error message.\n",
    "    - **`warning()`**: Continues execution but issues a warning.\n\n",
    "  - Example:\n",
    "    ```R\n",
    "    add <- function(vec, na.rm = TRUE) {\n",
    "      if(!is.numeric(vec)) stop('Input must be numeric')\n",
    "      if(sum(is.na(vec)) > 0) warning('NA values detected')\n",
    "      if(na.rm) vec <- vec[!is.na(vec)]\n",
    "      return(sum(vec))\n",
    "    }\n",
    "    ```\n\n",
    "---\n\n",
    "### 5. Local vs Global Environment\n",
    "  - Functions run in their **own environment**:\n",
    "    - Variables inside functions do not affect the global environment.\n",
    "    - Use `return()` to pass values back to the global environment.\n\n",
    "  - Example:\n",
    "    ```R\n",
    "    test_var <- 10\n",
    "    square <- function(x) {\n",
    "      test_var <- x\n",
    "      return(x^2)\n",
    "    }\n",
    "    square(5)  # Returns 25, does not affect `test_var` globally.\n",
    "    ```\n\n",
    "  - **Bad Practice**: Relying on global variables inside functions:\n",
    "    ```R\n",
    "    test_var <- 10\n",
    "    square <- function() {\n",
    "      return(test_var^2)\n",
    "    }\n",
    "    square()  # Works, but depends on `test_var` being defined globally.\n",
    "    ```\n\n",
    "---\n\n",
    "### 6. Summary of Best Practices\n",
    "  1. Functions make code reusable and modular.\n",
    "  2. Use error handling (`stop`, `warning`) to make functions robust.\n",
    "  3. Avoid relying on global variables; define variables explicitly inside functions.\n",
    "  4. Save reusable functions in `.R` scripts for easy sourcing and maintainability.\n"
  )
}
