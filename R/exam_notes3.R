#' Exam Notes 3: Implicit Loops, Custom Functions, and Reusability
#'
#' Provides a cheat sheet with notes on implicit loops, custom functions, reusability, error handling, and local vs global environment concepts.
#'
#' @return A string containing formatted exam notes for quick reference.
#' @examples
#' exam_notes3()
#' @export
exam_notes3 <- function() {
  paste(
    "### Implicit Loops",
    "- **apply(x, margin, func, args)**: Apply a function across rows (margin=1) or columns (margin=2) of a matrix or data frame.",
    "- Row sums: `apply(mat, 1, sum)`",
    "- Column means: `apply(mat, 2, mean, na.rm=TRUE)`",
    "- Example: Compute row means while handling missing values:",
    "  formatted_data <- matrix(c(1, NA, 3, 4), nrow=2)",
    "  apply(formatted_data, 1, mean, na.rm=TRUE)",
    "- **sapply(x, func)**: Simplifies results from applying a function to elements of a vector or list.",
    "- Example: `sapply(1:5, function(x) x^2)` -> Squares numbers 1 to 5.",
    "- **lapply(x, func)**: Similar to `sapply`, but always returns a list.",
    "- Example: `lapply(1:5, function(x) x^2)` -> Returns a list of squares.",
    "",
    "---",
    "",
    "### Custom Functions",
    "- **Defining Functions**: Functions encapsulate reusable code. Define using `function()`:",
    "  add <- function(a, b) {",
    "    return(a + b)",
    "  }",
    "  add(3, 5) # Returns 8",
    "",
    "---",
    "",
    "### Reusability",
    "- Save functions in an `.R` script (e.g., `my_functions.R`) and load them using:",
    "  source('my_functions.R')",
    "- This makes functions reusable and allows for cleaner scripts.",
    "",
    "---",
    "",
    "### Error Handling",
    "- **Validation with `stop()` and `warning()`**:",
    "  - **`stop()`**: Ends the function and throws an error message.",
    "  - **`warning()`**: Continues the function but issues a warning.",
    "- Example:",
    "  add <- function(vec, na.rm=TRUE) {",
    "    if(!is.numeric(vec)) stop('Input must be numeric')",
    "    if(sum(is.na(vec)) > 0) warning('NA values detected')",
    "    if(na.rm) vec <- vec[!is.na(vec)]",
    "    return(sum(vec))",
    "  }",
    "",
    "---",
    "",
    "### Local vs Global Environment",
    "- Functions run in their **own environment**:",
    "- Variables defined inside functions do not affect the global environment.",
    "- Use `return()` to pass values back to the global environment.",
    "- Example:",
    "  test_var <- 10",
    "  square <- function(x) {",
    "    test_var <- x",
    "    return(x^2)",
    "  }",
    "  square(5) # Returns 25, does not affect test_var in the global environment.",
    "- **Bad Practice**: Relying on global variables:",
    "  test_var <- 10",
    "  square <- function() {",
    "    return(test_var^2)",
    "  }",
    "  square() # Works, but depends on test_var being defined globally.",
    "",
    "---",
    "",
    "### Summary of Functions",
    "1. Functions make code reusable and modular.",
    "2. Use error handling (`stop`, `warning`) to make functions robust.",
    "3. Always define variables explicitly inside functions to avoid dependency on the global environment.",
    "4. Save reusable functions in scripts for easy sourcing.",
    sep = "\n"
  )
}
