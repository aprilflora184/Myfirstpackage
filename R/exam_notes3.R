#' Exam Notes 3: Implicit Loops, Custom Functions, and Reusability
#'
#' Provides a cheat sheet with notes on implicit loops, custom functions, reusability, error handling,
#' and local vs global environment concepts.
#'
#' @return A string containing formatted exam notes for quick reference.
#' @examples
#' exam_notes3()
#' @export
exam_notes3 <- function() {
  paste(
    "### Exam Notes 3: Quick R Reference",
    "",
    "### 1. Implicit Loops",
    "  - **`apply(x, margin, func, args)`**: Apply a function across rows or columns of a matrix/data frame.",
    "    - **`margin = 1`**: Apply across rows.",
    "    - **`margin = 2`**: Apply across columns.",
    "    - Example: Compute row means while handling missing values:",
    "      ```R",
    "      mat <- matrix(c(1, NA, 3, 4), nrow = 2)",
    "      apply(mat, 1, mean, na.rm = TRUE)",
    "      ```",
    "",
    "  - **`sapply(x, func)`**: Simplifies results when applying a function to vector/list elements.",
    "    - Example: `sapply(1:5, function(x) x^2)` -> Squares numbers 1 to 5.",
    "",
    "  - **`lapply(x, func)`**: Similar to `sapply`, but always returns a list.",
    "    - Example: `lapply(1:5, function(x) x^2)` -> Returns a list of squares.",
    "",
    "---",
    "",
    "### 2. Custom Functions",
    "  - Functions encapsulate reusable code. Define functions using `function()`.",
    "    - Example:",
    "      ```R",
    "      add <- function(a, b) {",
    "        return(a + b)",
    "      }",
    "      add(3, 5)  # Returns 8",
    "      ```",
    "",
    "---",
    "",
    "### 3. Reusability",
    "  - Save functions in an `.R` script (e.g., `my_functions.R`) and load them using:",
    "    ```R",
    "    source('my_functions.R')",
    "    ```",
    "  - This makes functions reusable and allows for cleaner, modular scripts.",
    "",
    "---",
    "",
    "### 4. Error Handling",
    "  - **Validation with `stop()` and `warning()`**:",
    "    - **`stop()`**: Ends the function and throws an error message.",
    "    - **`warning()`**: Continues execution but issues a warning.",
    "",
    "  - Example:",
    "    ```R",
    "    add <- function(vec, na.rm = TRUE) {",
    "      if(!is.numeric(vec)) stop('Input must be numeric')",
    "      if(sum(is.na(vec)) > 0) warning('NA values detected')",
    "      if(na.rm) vec <- vec[!is.na(vec)]",
    "      return(sum(vec))",
    "    }",
    "    ```",
    "",
    "---",
    "",
    "### 5. Local vs Global Environment",
    "  - Functions run in their **own environment**:",
    "    - Variables inside functions do not affect the global environment.",
    "    - Use `return()` to pass values back to the global environment.",
    "",
    "  - Example:",
    "    ```R",
    "    test_var <- 10",
    "    square <- function(x) {",
    "      test_var <- x",
    "      return(x^2)",
    "    }",
    "    square(5)  # Returns 25, does not affect `test_var` globally.",
    "    ```",
    "",
    "  - **Bad Practice**: Relying on global variables inside functions:",
    "    ```R",
    "    test_var <- 10",
    "    square <- function() {",
    "      return(test_var^2)",
    "    }",
    "    square()  # Works, but depends on `test_var` being defined globally.",
    "    ```",
    "",
    "---",
    "",
    "### 6. Summary of Best Practices",
    "  1. Functions make code reusable and modular.",
    "  2. Use error handling (`stop`, `warning`) to make functions robust.",
    "  3. Avoid relying on global variables; define variables explicitly inside functions.",
    "  4. Save reusable functions in `.R` scripts for easy sourcing and maintainability.",
    sep = "\n"
  )
}
